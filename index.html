<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>偷心大盗（纯红桃心，修复哭泣 BUG，移动兼容）</title>
<style>
  html,body{height:100%;margin:0;background:
    radial-gradient(1200px 700px at 50% 35%, rgba(80,110,180,0.98), transparent 20%),
    linear-gradient(180deg,#14182b,#0b0f1a);color:#ddd;font-family:system-ui,Arial;overflow:hidden}
  .stage{position:relative;width:100%;height:100%;touch-action:none;-webkit-user-select:none;user-select:none}
  .bg-count{position:absolute;inset:0;display:grid;place-items:center;font-weight:800;font-size:clamp(64px,14vw,220px);color:rgba(255,255,255,0.08);pointer-events:none}
  .ring{position:absolute;width:80px;height:80px;border-radius:50%;border:3px solid rgba(255,255,255,0.92);transform:translate3d(-50%,-50%,0);will-change:transform;pointer-events:none}
  .heart{position:absolute;width:64px;height:64px;transform:translate3d(-50%,-50%,0);will-change:transform;pointer-events:none}
  .tear{position:absolute;width:6px;height:10px;border-radius:50%;background:linear-gradient(#9fd6ff,#4da6ff);pointer-events:none;box-shadow:0 3px 8px rgba(0,0,0,.25)}
</style>
</head>
<body>
<div class="stage" id="stage">
  <div class="bg-count" id="bgCount">0</div>
  <div id="ring" class="ring" aria-hidden="true"></div>
  <div id="heart" class="heart" aria-hidden="true">
    <!-- 纯红色桃心 -->
    <svg viewBox="0 0 64 64" width="100%" height="100%" aria-hidden="true" focusable="false">
      <path d="M32 57 C30 55,10 40,7 27 C5 18,10 7,21 7 C27 7,32 12,32 14 C32 12,37 7,43 7 C54 7,59 18,57 27 C54 40,34 55,32 57 Z" fill="#ff0000"/>
    </svg>
  </div>
</div>

<script>
/* ---------- 状态 ---------- */
const stage = document.getElementById('stage');
const ringEl = document.getElementById('ring');
const heartEl = document.getElementById('heart');
const bgCount = document.getElementById('bgCount');

let vw = innerWidth, vh = innerHeight;
let caught = 0;

const ring = { x: vw/2, y: vh/2, px: vw/2, py: vh/2, vx:0, vy:0, dragging:false, radius:40, locked:false };
const heart = {
  x: vw*0.33, y: vh/2,
  vx:0, vy:0, angle:0,
  grabbed:false,
  centerTarget:null, centerT:0,
  tearTimer: null // 用于周期性哭泣的定时器句柄
};

/* ---------- 常量 ---------- */
const BASE_THREAT = 170;
const BASE_SAFE = 260;
const SENS_PER_CATCH = 0.06;
const CENTER_REFRESH = 300;
const CENTER_RADIUS_RATIO = 0.12;

/* ---------- 工具 ---------- */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const len = (x,y)=>Math.hypot(x,y);
const norm = (x,y)=>{ const L=len(x,y)||1; return {x:x/L,y:y/L}; };
const setTransform = (el,x,y,rot=0)=>{ el.style.transform = `translate3d(${x}px, ${y}px, 0) translate(-50%,-50%) rotate(${rot}deg)`; };

/* ---------- 泪滴（仅在被抓住期间触发） ---------- */
function spawnTear(x,y,angle){
  const el = document.createElement('div'); el.className='tear';
  el.style.left = x + 'px'; el.style.top = y + 'px';
  const rad = angle*Math.PI/180, dx=Math.cos(rad)*36, dy=Math.sin(rad)*36;
  el.animate([{opacity:1, transform:'translate(0,0)'},{opacity:0, transform:`translate(${dx}px,${dy}px)`}],{duration:800,easing:'ease-out'});
  stage.appendChild(el); setTimeout(()=>el.remove(),820);
}
function cryBurst(){
  // 仅在确实被抓住时产生泪滴
  if(!heart.grabbed) return;
  spawnTear(heart.x-10, heart.y-15, -140 + Math.random()*40);
  spawnTear(heart.x+10, heart.y-15, -40 + Math.random()*40);
}

/* ---------- 计算辅助 ---------- */
function computeL(){
  const screenHalf = Math.min(vw,vh)/2;
  const raw = 120 * Math.pow(1.5, Math.max(0, caught-1));
  const minL = Math.max(ring.radius+6, 60);
  return clamp(raw, minL, screenHalf - 20);
}
function computeP(L){
  const cx=ring.x, cy=ring.y;
  let dx = heart.x - cx, dy = heart.y - cy, d = len(dx,dy);
  if(d < 1e-6){ const a=Math.random()*Math.PI*2; return {x:cx+Math.cos(a)*L,y:cy+Math.sin(a)*L}; }
  const u = norm(dx,dy);
  return { x: clamp(cx + u.x*L, 20, vw-20), y: clamp(cy + u.y*L, 20, vh-20) };
}
function updateCenterTarget(){
  const now = Date.now();
  if(!heart.centerTarget || now - heart.centerT > CENTER_REFRESH){
    const r = Math.min(vw,vh) * CENTER_RADIUS_RATIO;
    const a = Math.random()*Math.PI*2, rr = Math.random()*r;
    heart.centerTarget = { x: vw/2 + Math.cos(a)*rr, y: vh/2 + Math.sin(a)*rr };
    heart.centerT = now;
  }
}

/* ---------- 管理哭泣定时器 ---------- */
function startTearTimerIfNeeded(){
  if(heart.tearTimer) return;
  // 周期性尝试哭泣，但 cryBurst 内部会检查 heart.grabbed
  heart.tearTimer = setInterval(()=>{
    if(heart.grabbed && Math.random() < 0.18) cryBurst();
  }, 900);
}
function stopTearTimer(){
  if(heart.tearTimer){
    clearInterval(heart.tearTimer);
    heart.tearTimer = null;
  }
}

/* ---------- 事件处理（Pointer Events 统一） ---------- */
let lastPointerTime = 0;
const POINTER_THROTTLE_MS = 8;

stage.addEventListener('pointerdown', e=>{
  if(ring.locked) return;
  const r = ringEl.getBoundingClientRect();
  if(e.clientX >= r.left && e.clientX <= r.right && e.clientY >= r.top && e.clientY <= r.bottom){
    ring.dragging = true;
    e.preventDefault();
  }
});
window.addEventListener('pointerup', ()=>{
  ring.dragging = false;
  // 释放时确保停止哭泣并让心逃跑
  if(heart.grabbed){
    heart.grabbed = false;
    stopTearTimer();
    const L = computeL(); const P = computeP(L);
    heart.vx += (P.x - heart.x) * 0.02;
    heart.vy += (P.y - heart.y) * 0.02;
  }
});
window.addEventListener('pointermove', e=>{
  const now = performance.now();
  if(now - lastPointerTime < POINTER_THROTTLE_MS) return;
  lastPointerTime = now;
  if(!ring.dragging || ring.locked) return;
  ring.px = ring.x; ring.py = ring.y;
  ring.x = clamp(e.clientX, 0, vw); ring.y = clamp(e.clientY, 0, vh);
  ring.vx = ring.x - ring.px; ring.vy = ring.y - ring.py;
  setTransform(ringEl, ring.x, ring.y, 0);
});

/* ---------- 主循环 ---------- */
function loop(){
  requestAnimationFrame(loop);
  vw = innerWidth; vh = innerHeight;
  ring.vx *= 0.92; ring.vy *= 0.92;

  const dx = heart.x - ring.x, dy = heart.y - ring.y, dist = len(dx,dy);
  const sensitivity = Math.min(1 + caught * SENS_PER_CATCH, 2.6);

  if(heart.grabbed){
    heart.x = ring.x + (Math.random()*6 - 3);
    heart.y = ring.y + (Math.random()*6 - 3);
    heart.angle = Math.sin(Date.now()/80) * 12;
    // 启动哭泣定时器（仅在被抓住时）
    startTearTimerIfNeeded();
  } else {
    const catchTol = 6 + Math.floor(Math.min(caught,40)*1.2);
    if(ring.dragging && dist < (ring.radius - catchTol)){
      heart.grabbed = true;
      caught++; bgCount.textContent = caught;
      // 启动哭泣定时器
      startTearTimerIfNeeded();
    } else {
      let fx=0, fy=0;
      const threat = BASE_THREAT * sensitivity;
      if(dist < threat){
        const away = norm(dx,dy);
        fx += away.x * (280 * sensitivity);
        fy += away.y * (280 * sensitivity);
        fx += -ring.vx * (1.1 * sensitivity);
        fy += -ring.vy * (1.1 * sensitivity);
        fx += (-ring.vy) * (0.45 * sensitivity);
        fy += ( ring.vx) * (0.45 * sensitivity);
        fx += (Math.random()-0.5) * (90 * sensitivity);
        fy += (Math.random()-0.5) * (90 * sensitivity);
      } else if(Math.random() < 0.006 * sensitivity){
        fx += (Math.random()-0.5) * (160 * sensitivity);
        fy += (Math.random()-0.5) * (160 * sensitivity);
      }

      const centerW = vw*0.4, centerH = vh*0.4;
      const left = (vw - centerW)/2, top = (vh - centerH)/2;
      const outside = ring.x < left || ring.x > left + centerW || ring.y < top || ring.y > top + centerH;
      if(outside){
        updateCenterTarget();
        const tx = heart.centerTarget.x, ty = heart.centerTarget.y;
        const to = norm(tx - heart.x, ty - heart.y);
        const attract = 120 * (1 + (sensitivity-1)*0.25) * 0.6;
        fx += to.x * attract; fy += to.y * attract;
      } else {
        heart.centerTarget = null;
      }

      const steer = norm(fx,fy);
      const safeDist = BASE_SAFE * (1 + (sensitivity-1)*0.6);
      heart.tx = heart.x + steer.x * safeDist;
      heart.ty = heart.y + steer.y * safeDist;

      const targetVx = (heart.tx - heart.x) * 0.016 * (1 + (sensitivity-1)*0.25);
      const targetVy = (heart.ty - heart.y) * 0.016 * (1 + (sensitivity-1)*0.25);
      heart.vx = heart.vx * 0.88 + targetVx * 0.12;
      heart.vy = heart.vy * 0.88 + targetVy * 0.12;

      heart.x += heart.vx; heart.y += heart.vy;
      heart.angle = Math.sin(Date.now()/140) * 6;

      if(heart.x < 0) heart.x += vw;
      if(heart.x > vw) heart.x -= vw;
      if(heart.y < 0) heart.y += vh;
      if(heart.y > vh) heart.y -= vh;
    }
  }

  // GPU 更新
  setTransform(heartEl, heart.x, heart.y, heart.angle);
  setTransform(ringEl, ring.x, ring.y, 0);
}
requestAnimationFrame(loop);

/* ---------- 初始化 ---------- */
setTransform(ringEl, ring.x, ring.y, 0);
setTransform(heartEl, heart.x, heart.y, 0);
bgCount.textContent = caught;
window.addEventListener('resize', ()=>{ vw = innerWidth; vh = innerHeight; });

</script>
</body>
</html>
